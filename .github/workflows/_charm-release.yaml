name: Release charm to Edge

on:
  workflow_call:
    inputs:
      release-channel:
        description: |
          Name of the Charmhub channel (with the format 'latest/edge') to release the charm to.
        type: string
        required: true
      charm-path:
        type: string
        required: false
        default: .
      runners:
        description: |
          Json matrix of the runners to use to build and release the charm.
          Example: ...
        type: string
        required: false
        default: "ubuntu-latest"
      charmcraft-channel:
        type: string
        required: true
        description: |
          The snap channel from which to install Charmcraft.
      git-tag-prefix:
        description: "Tag prefix to use for the tag of the GitHub release."
        required: false
        type: string
    secrets:
      CHARMHUB_TOKEN:
        required: true
      OBSERVABILITY_NOCTUA_TOKEN:
        required: true

jobs:
  build:
    name: Release the charm
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        runner: ${{ fromJSON(inputs.runners) }}
    outputs:
      charms: ${{ steps.pack.outputs.charms }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup LXD
        uses: canonical/setup-lxd@main
      - name: Install charmcraft
        run: |
          sudo snap install jq
          sudo snap install charmcraft --classic --channel="${{ inputs.charmcraft-channel }}"
      - name: Cache wheels
        uses: actions/cache@v4
        with:
          path: /home/runner/snap/charmcraft/common/cache/charmcraft
          key: ${{ runner.os }}-wheel-cache-${{ hashFiles('./uv.lock') }}
          # If the above cache key doesn't match, it's because the uv.lock has changed.
          # Even so, pre-existing caches may still contain useful cached builds for some
          # portion of the dependencies, and restore-keys can partially match a cache.
          restore-keys: |
            ${{ runner.os }}-wheel-cache-
      - name: Pack charm(s)
        id: pack
        run: |
          (cd ${{ inputs.charm-path }}; charmcraft pack)
          export CHARMS=$(basename -a ${{ inputs.charm-path }}/*.charm | jq -R -s -c 'split("\n")[:-1]')
          echo "charms=$CHARMS"
          echo "charms=$CHARMS" >> $GITHUB_OUTPUT
      - name: Store charm(s)
        uses: actions/upload-artifact@v4
        with:
          name: charms
          path: ${{ inputs.charm-path }}/*.charm
      - name: Get charm name
        id: get-charm-name
        run: |
          # Read charm name from metadata.yaml or charmcraft.yaml
          cd "${{ inputs.charm-path }}"
          charm_name=$(yq .name metadata.yaml 2>/dev/null || yq .name charmcraft.yaml)
          echo "charm_name=$charm_name" >> $GITHUB_OUTPUT
      - name: Release charm to Charmhub and GitHub
        id: upload
        env:
          CHARMCRAFT_AUTH: ${{ secrets.CHARMHUB_TOKEN }}
          CHARM_NAME: ${{ steps.get-charm-name.outputs.charm_name }}
          GH_TOKEN: ${{ secrets.OBSERVABILITY_NOCTUA_TOKEN }}
          TAG_PREFIX: ${{ inputs.git-tag-prefix }}
          RELEASE_CHANNEL: ${{ inputs.release-channel }}
        run: |
          # Upload charm to CharmHub and release it
          # uploaded_charm has the following JSON format:
          # {"name": "o11y-tester", "revision": 12, "resources": [
          #   {"name": "httpbin-image", "revision": 1, "upstream_source": "kennethreitz/httpbin"}
          # ]}
          cd "${{ inputs.charm-path }}"
          file_paths="$(find -name '*.charm' -printf '%f ')"
          # For all the charms built on this architecture: release them
          for path in ${file_paths}; do
            uploaded_charm="$( \
              uvx --from git+https://github.com/lucabello/noctua noctua charm release \
                "${{ steps.get-charm-name.outputs.charm_name }}" \
                --path "${{ matrix.path }}" \
                --channel "${{ inputs.release-channel }}" \
                --json \
            )"
            pretty_uploaded_charm="$(echo "$uploaded_charm" | jq)"
            echo "${CHARM_NAME} has been released to ${RELEASE_CHANNEL}"
            echo "$pretty_uploaded_charm"
            # Create a git tag and push it
            ## Configure git
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git config --global user.name "github-actions[bot]"
            ## Use the latest commit message as the tag message
            git log -1 --pretty=%B > tag-message
            revision="$(echo "$uploaded_charm" | jq .revision)"
            git tag --annotate "${TAG_PREFIX}rev${revision}" --file=tag-message
            rm -f tag-message
            git push origin --tags
            # Create a GitHub release 
            release_name="Revision $revision"
            ## Add the charm information to the release body
            body_charm="$(print "\`\`\`json\n${pretty_uploaded_charm}\n\`\`\`")"
            current_date="$(date -u +"%B %e, %Y at %H:%M UTC")"
            body_meta="$(print "Released to *${RELEASE_CHANNEL}* on ${current_date}")"
            body="$(print "${body_charm}\n\n${body_meta}")"
            ## Create the GitHub release from the previously-created tag
            gh release create "${TAG_PREFIX}rev${revision}" --notes="$body" --generate-notes
          done
