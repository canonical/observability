locals {
  stack_id = uuidv5("dns", "cf_template")
  stack_name = "cf_template"
}

data "aws_availability_zones" "available" {
  state = "available"
}

resource "aws_iam_role" "notify_ms_portal_lambda_execution_role" {
  assume_role_policy = {
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = [
            "lambda.amazonaws.com"
          ]
        }
        Action = [
          "sts:AssumeRole"
        ]
      }
    ]
  }
  force_detach_policies = [
    {
      PolicyName = "root"
      PolicyDocument = {
        Version = "2012-10-17"
        Statement = [
          {
            Effect = "Allow"
            Action = [
              "logs:*"
            ]
            Resource = "*"
          }
        ]
      }
    }
  ]
}

resource "aws_lambda_function" "notify_ms_portal" {
  handler = "index.lambda_handler"
  role = aws_iam_role.notify_ms_portal_lambda_execution_role.arn
  code_signing_config_arn = {
    ZipFile = "import json
import urllib3
http = urllib3.PoolManager()
def send_response(event, context, response_status, response_data):
    response_url = event['ResponseURL']
    response_body = {
        "Status": response_status,
        "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
        "PhysicalResourceId": context.log_stream_name,
        "StackId": event['StackId'],
        "RequestId": event['RequestId'],
        "LogicalResourceId": event['LogicalResourceId'],
        "Data": response_data
    }
    json_response_body = json.dumps(response_body)
    headers = {
        'content-type': '',
        'content-length': str(len(json_response_body))
    }
    try:
        response = http.request('PUT', response_url, body=json_response_body, headers=headers)
        print("Status code: " + response.status)
    except Exception as e:
        print("send(..) failed executing requests.put(..): " + str(e))
def lambda_handler(event, context):
    print("Received event: " + json.dumps(event))
    try:
        if event['RequestType'] in ['Create', 'Update', 'Delete']:
            if event['RequestType'] == 'Create':
              state = 'Deploying'
            if event['RequestType'] == 'Delete':
              state = 'Deleted'
            webhook_url = "https://portal.managed.canonical.com/gitops/api/aws-notify"
            data = {
                "applicationId": event['StackId'],
                "provisioningState": state,
                "plan": {
                  "name": "kubeflow-aws",
                  "product": "managed-kubeflow",
                  "version": "0.0.1",
                  "publisher": "canonical-test"
                }
            }
            http.request('POST', webhook_url, body=json.dumps(data), headers={'Content-Type': 'application/json'})
            send_response(event, context, "SUCCESS", {})
        else:
            send_response(event, context, "FAILED", {"Message": "Unexpected event received from CloudFormation"})
    except Exception as e:
        print(e)
        send_response(event, context, "FAILED", {"Message": str(e)})
"
  }
  runtime = "python3.8"
  timeout = 300
}

resource "aws_codecommit_trigger" "notify_ms_portal_trigger" {
  // CF Property(ServiceToken) = aws_lambda_function.notify_ms_portal.arn
}

resource "aws_vpc" "managed_app_vpc" {
  cidr_block = "10.0.0.0/16"
  enable_dns_support = true
  enable_dns_hostnames = true
}

resource "aws_internet_gateway" "managed_internet_gateway" {}

resource "aws_route_table" "managed_public_route_table" {
  vpc_id = aws_vpc.managed_app_vpc.arn
}

resource "aws_vpn_gateway_attachment" "managed_internet_gateway_attachment" {
  vpc_id = aws_vpc.managed_app_vpc.arn
}

resource "aws_route" "managed_default_public_route" {
  route_table_id = aws_route_table.managed_public_route_table.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id = aws_internet_gateway.managed_internet_gateway.id
}

resource "aws_ec2_fleet" "nat_gateway_eip" {
  // CF Property(Domain) = "vpc"
}

resource "aws_nat_gateway" "nat_gateway" {
  allocation_id = aws_ec2_fleet.nat_gateway_eip.id
  subnet_id = aws_subnet.managed_app_subnet.id
}

resource "aws_subnet" "managed_app_subnet" {
  vpc_id = aws_vpc.managed_app_vpc.arn
  cidr_block = "10.0.10.0/24"
  availability_zone = element(data.aws_availability_zones.available.names, 0)
  map_public_ip_on_launch = true
}

resource "aws_route_table_association" "managed_subnet_route_table_association" {
  route_table_id = aws_route_table.managed_public_route_table.id
  subnet_id = aws_subnet.managed_app_subnet.id
}

resource "aws_subnet" "managed_app_subnet2" {
  vpc_id = aws_vpc.managed_app_vpc.arn
  cidr_block = "10.0.20.0/24"
  availability_zone = element(// Unable to resolve Fn::GetAZs with value: "" because local variable 'az_data' referenced before assignment, 1)
  map_public_ip_on_launch = true
}

resource "aws_route_table_association" "managed_subnet2_route_table_association" {
  route_table_id = aws_route_table.managed_public_route_table.id
  subnet_id = aws_subnet.managed_app_subnet2.id
}

resource "aws_iam_role" "managed_app_role" {
  name = join("-", ["managed-role-", element(split(""-"", element(split(""/"", local.stack_id), 2)), 4)])
  assume_role_policy = {
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
        Action = "sts:AssumeRole"
      }
    ]
  }
}

resource "aws_iam_policy" "managed_role_policy" {
  name = "EC2FullAccessPolicy"
  // CF Property(Roles) = [
  //   aws_iam_role.managed_app_role.arn
  // ]
  policy = {
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "*"
        Resource = "*"
      }
    ]
  }
}

resource "aws_iam_instance_profile" "ec2_iam_instance_profile" {
  name = join("-", ["managed-instance-profile-", element(split(""-"", element(split(""/"", local.stack_id), 2)), 4)])
  role = [
    aws_iam_role.managed_app_role.arn
  ]
}

resource "aws_iam_user" "juju_iam_user" {
  name = join("-", ["juju-bootstrap", element(split(""-"", element(split(""/"", local.stack_id), 2)), 4)])
  // CF Property(Policies) = [
  //   {
  //     PolicyName = "AmazonEC2FullAccessPolicy"
  //     PolicyDocument = {
  //       Version = "2012-10-17"
  //       Statement = [
  //         {
  //           Effect = "Allow"
  //           Action = "*"
  //           Resource = "*"
  //         }
  //       ]
  //     }
  //   }
  // ]
}

resource "aws_security_group" "bootstrap_security_group" {
  description = "Allow SSH, HTTP, and HTTPS traffic"
  vpc_id = aws_vpc.managed_app_vpc.arn
  ingress = [
    {
      protocol = "tcp"
      from_port = 22
      to_port = 22
      cidr_blocks = "0.0.0.0/0"
    },
    {
      protocol = "tcp"
      from_port = 80
      to_port = 80
      cidr_blocks = "0.0.0.0/0"
    },
    {
      protocol = "tcp"
      from_port = 443
      to_port = 443
      cidr_blocks = "0.0.0.0/0"
    }
  ]
}

resource "aws_instance" "bootstrap_instance" {
  // CF Property(ImageId) = "{{resolve:ssm:/aws/service/canonical/ubuntu/server/jammy/stable/current/amd64/hvm/ebs-gp2/ami-id}}"
  instance_type = "m7i.large"
  iam_instance_profile = aws_iam_instance_profile.ec2_iam_instance_profile.arn
  subnet_id = aws_subnet.managed_app_subnet.id
  vpc_security_group_ids = [
    aws_security_group.bootstrap_security_group.arn
  ]
  user_data = base64encode("#!/bin/bash -x
sudo -u ubuntu ssh-import-id-lp dparv
curl -d "cloud=aws" -d "app=kubeflow" -d "application_id=${local.stack_id}" https://portal.managed.canonical.com/gitops/api/bootstrap.sh -o bootstrap.sh
chmod +x bootstrap.sh
./bootstrap.sh > stdout 2> stderr
")
}

resource "aws_iam_role" "eks_cluster_role" {
  assume_role_policy = {
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "eks.amazonaws.com"
        }
        Action = [
          "sts:AssumeRole",
          "sts:TagSession"
        ]
      }
    ]
  }
  managed_policy_arns = [
    "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy",
    "arn:aws:iam::aws:policy/AmazonEKSNetworkingPolicy",
    "arn:aws:iam::aws:policy/AmazonEKSLoadBalancingPolicy",
    "arn:aws:iam::aws:policy/AmazonEKSBlockStoragePolicy",
    "arn:aws:iam::aws:policy/AmazonEKSComputePolicy"
  ]
}

resource "aws_eks_cluster" "eks_cluster" {
  name = "${local.stack_name}-cluster"
  role_arn = aws_iam_role.eks_cluster_role.arn
  access_config {
    authentication_mode = "API_AND_CONFIG_MAP"
  }
  compute_config {
    enabled = true
  }
  storage_config {
    block_storage {
      enabled = true
    }
  }
  kubernetes_network_config {
    elastic_load_balancing {
      enabled = true
    }
  }
  vpc_config = {
    SubnetIds = [
      aws_subnet.managed_app_subnet.id,
      aws_subnet.managed_app_subnet2.id
    ]
  }
}

resource "aws_eks_addon" "eks_kube_proxy_addon" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  addon_name = "kube-proxy"
}

resource "aws_eks_addon" "eks_core_dns_addon" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  addon_name = "coredns"
}

resource "aws_eks_addon" "eks_vpc_cni_addon" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  addon_name = "vpc-cni"
}

resource "aws_iam_role" "node_group_role" {
  assume_role_policy = {
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
        Action = "sts:AssumeRole"
      }
    ]
  }
  managed_policy_arns = [
    "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy",
    "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly",
    "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
  ]
}

resource "aws_eks_node_group" "eks_node_group" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  node_role_arn = aws_iam_role.node_group_role.arn
  subnet_ids = [
    aws_subnet.managed_app_subnet.id,
    aws_subnet.managed_app_subnet2.id
  ]
  scaling_config = {
    MinSize = 3
    MaxSize = 3
    DesiredSize = 3
  }
  disk_size = 100
  instance_types = [
    "t3.xlarge"
  ]
  ami_type = "AL2_x86_64"
}

resource "aws_eks_node_group" "eks_node_group_gpu" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  node_role_arn = aws_iam_role.node_group_role.arn
  subnet_ids = [
    aws_subnet.managed_app_subnet.id,
    aws_subnet.managed_app_subnet2.id
  ]
  scaling_config = {
    MinSize = 0
    MaxSize = 3
  }
  disk_size = 100
  instance_types = [
    "g4dn.xlarge"
  ]
  ami_type = "AL2_x86_64_GPU"
  labels = {
    type = "gpu"
  }
  taint = [
    {
      Key = "sku"
      Value = "gpu"
      Effect = "NO_SCHEDULE"
    }
  ]
}

resource "aws_eks_access_entry" "eks_access_entry" {
  cluster_name = aws_eks_cluster.eks_cluster.arn
  principal_arn = aws_iam_user.juju_iam_user.arn
  // CF Property(AccessPolicies) = [
  //   {
  //     PolicyArn = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminPolicy"
  //     AccessScope = {
  //       Type = "cluster"
  //     }
  //   },
  //   {
  //     PolicyArn = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
  //     AccessScope = {
  //       Type = "cluster"
  //     }
  //   }
  // ]
  type = "STANDARD"
}